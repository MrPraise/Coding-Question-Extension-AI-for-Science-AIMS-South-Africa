# -*- coding: utf-8 -*-
"""Coding_Question_Extension.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LWQJll2BXVPz4m6kGKdUJrCH26g239hx

# **Recommendations on Extending the Function**


The following could be done in extending the function:

1. **Optimize Path Calculation**: We can implement a method to find the shortest path between given points using suitable algorithms like Prim's. This will allow for flexibility in defining paths and ensure the most cost-effective route is chosen at any given time.


2. **Error Handling**:  Errors could be handled in the funtion by identifying potential issues like invalid inputs or unreachable nodes. This will make the code more robust and prevent unexpected behavior.

3. **Visualization**: Just like I did in the code below, we can visualize the network and the selected path. Visualization can help us in understanding the network structure and the chosen path, making it easier to debug and analyze the algorithm.
"""

import networkx as nx
import matplotlib.pyplot as plt

def minimum_saving(input_network: str) -> int:
    # Parse the input network to create a matrix representing connection costs
    network = []
    for row in input_network.strip().split('\n'):
        # Replace empty strings and '-' with None to represent missing connections
        row_values = [int(cost) if cost and cost != '-' else None for cost in row.split(',')]
        network.append(row_values)

    # Visualize the network
    G = nx.Graph()
    labels = {}
    for i in range(len(network)):
        for j in range(len(network[i])):
            if network[i][j] is not None:
                G.add_edge(chr(ord('A')+i), chr(ord('A')+j), weight=network[i][j])
                labels[(chr(ord('A')+i), chr(ord('A')+j))] = network[i][j]

    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
    plt.show()

    # Connect points in the specified order: E -> B -> D -> G -> F -> C -> D -> A
    order = ['E', 'B', 'D', 'G', 'F', 'C', 'D', 'A']
    simplified_network_cost = 0
    prev_point = order[0]
    for next_point in order[1:]:
        cost = network[ord(prev_point) - ord('A')][ord(next_point) - ord('A')]
        if cost is not None:
            simplified_network_cost += cost
        prev_point = next_point

    # Calculate the total cost of the original network
    total_original_cost = sum(network[i][j] for i in range(len(network)) for j in range(i + 1, len(network[i])) if network[i][j] is not None)

    # Calculate maximum saving
    min_saving = total_original_cost - simplified_network_cost

    return min_saving

# Input network with costs
input_network = '''
-,14,10,19,-,-,-,
14,-,-,15,18,-,-
10,-,-,26,-,29,-,
19,15,26,-,16,17,21,
-,18,-,16,-,-,9,
-,-,29,17,-,-,25,
-,-,-,21,9,25,-,
'''

# Calculate miniimum saving
min_saving = minimum_saving(input_network)
print("Minimum saving:", min_saving)

"""In conclusion:
This means that only 66 cost value(minimum saving) was saved from the original network compared to the maximum saving of 138.
"""